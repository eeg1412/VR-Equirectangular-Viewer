/**
 * VR Equirectangular Viewer
 * @version 1.0.9
 * @license MIT
 */
class VREquirectangularViewer{constructor(e={}){this.imageUrl=e.imageUrl||null,this.maxTextureSize=e.maxTextureSize||null,this.onError=e.onError||console.error,this.onVRStart=e.onVRStart||(()=>{}),this.onVREnd=e.onVREnd||(()=>{}),this.gl=null,this.canvas=null,this.canvasId="vr-equirectangular-"+Date.now()+"-"+Math.random().toString(36).slice(2,11),this.xrSession=null,this.xrRefSpace=null,this.shaderProgram=null,this.programInfo=null,this.sphereBuffers=null,this.texture=null,this.textureLoaded=!1,this.isInitialized=!1,this.autoDestroyOnExit=!0,this._onSessionEnd=this._onSessionEnd.bind(this)}async isVRSupported(){if(!navigator.xr)return!1;try{return await navigator.xr.isSessionSupported("immersive-vr")}catch(e){return!1}}_initWebGL(){return!!this.gl||(this.canvas=document.createElement("canvas"),this.canvas.id=this.canvasId,this.canvas.style.display="none",document.body.appendChild(this.canvas),this.gl=this.canvas.getContext("webgl2",{xrCompatible:!0,alpha:!1,antialias:!1,depth:!0,stencil:!1,powerPreference:"high-performance"})||this.canvas.getContext("webgl",{xrCompatible:!0,alpha:!1,antialias:!1,depth:!0,stencil:!1,powerPreference:"high-performance"}),this.gl?(this.gl.clearColor(0,0,0,1),this.gl.enable(this.gl.DEPTH_TEST),this.gl.disable(this.gl.CULL_FACE),!0):(this.onError("WebGL不可用"),!1))}_initShaders(){const e=this.gl,t=this._compileShader(e.VERTEX_SHADER,"\n            precision highp float;\n            attribute vec3 aPosition;\n            attribute vec2 aTexCoord;\n            uniform mat4 uModelViewMatrix;\n            uniform mat4 uProjectionMatrix;\n            varying vec2 vTexCoord;\n            \n            void main() {\n                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);\n                vTexCoord = aTexCoord;\n            }\n        "),r=this._compileShader(e.FRAGMENT_SHADER,"\n            precision highp float;\n            varying vec2 vTexCoord;\n            uniform sampler2D uTexture;\n            \n            void main() {\n                gl_FragColor = texture2D(uTexture, vTexCoord);\n            }\n        ");return!(!t||!r||(this.shaderProgram=e.createProgram(),e.attachShader(this.shaderProgram,t),e.attachShader(this.shaderProgram,r),e.linkProgram(this.shaderProgram),e.getProgramParameter(this.shaderProgram,e.LINK_STATUS)?(this.programInfo={program:this.shaderProgram,attribLocations:{position:e.getAttribLocation(this.shaderProgram,"aPosition"),texCoord:e.getAttribLocation(this.shaderProgram,"aTexCoord")},uniformLocations:{projectionMatrix:e.getUniformLocation(this.shaderProgram,"uProjectionMatrix"),modelViewMatrix:e.getUniformLocation(this.shaderProgram,"uModelViewMatrix"),texture:e.getUniformLocation(this.shaderProgram,"uTexture")}},0):(this.onError("着色器链接失败: "+e.getProgramInfoLog(this.shaderProgram)),1)))}_compileShader(e,t){const r=this.gl,i=r.createShader(e);return r.shaderSource(i,t),r.compileShader(i),r.getShaderParameter(i,r.COMPILE_STATUS)?i:(this.onError("着色器编译错误: "+r.getShaderInfoLog(i)),r.deleteShader(i),null)}_createSphere(){const e=this.gl,t=[],r=[],i=[];for(let e=0;e<=60;e++){const i=e*Math.PI/60,o=Math.sin(i),s=Math.cos(i);for(let i=0;i<=60;i++){const n=2*i*Math.PI/60,a=Math.sin(n),h=Math.cos(n)*o,l=s,c=a*o,u=i/60,d=e/60;t.push(50*h,50*l,50*c),r.push(u,d)}}for(let e=0;e<60;e++)for(let t=0;t<60;t++){const r=61*e+t,o=r+60+1;i.push(r,o,r+1),i.push(o,o+1,r+1)}const o=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,new Float32Array(t),e.STATIC_DRAW);const s=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,s),e.bufferData(e.ARRAY_BUFFER,new Float32Array(r),e.STATIC_DRAW);const n=e.createBuffer();e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n),e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(i),e.STATIC_DRAW),this.sphereBuffers={position:o,texCoord:s,indices:n,vertexCount:i.length}}async _loadTexture(){const e=this.gl;return new Promise((t,r)=>{this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,new Uint8Array([0,0,0,255]));const i=new Image;i.crossOrigin="anonymous",i.onload=()=>{let o=e.getParameter(e.MAX_TEXTURE_SIZE);console.log(`设备最大纹理尺寸: ${o}`),this.maxTextureSize&&(console.log(`配置最大纹理尺寸: ${this.maxTextureSize}`),o=Math.min(e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureSize),console.log(`使用最大纹理尺寸: ${o}`));let s=i;Math.max(i.width,i.height)>o&&(console.log(`图片尺寸过大(${i.width}x${i.height})，正在缩放到最大边长${o}...`),s=this._resizeImage(i,o)),console.log(`使用图片尺寸: ${s.width}x${s.height}`),e.bindTexture(e.TEXTURE_2D,this.texture);try{e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),this.textureLoaded=!0,t()}catch(e){r("纹理上传失败: "+e.message)}},i.onerror=()=>r("图片加载失败: "+this.imageUrl),i.src=this.imageUrl})}_resizeImage(e,t){const r=document.createElement("canvas"),i=r.getContext("2d"),o=t/Math.max(e.width,e.height);return r.width=Math.floor(e.width*o),r.height=Math.floor(e.height*o),i.imageSmoothingEnabled=!0,i.imageSmoothingQuality="high",i.drawImage(e,0,0,r.width,r.height),r}async enterVR(){if(!this.imageUrl)throw new Error("未设置全景图片URL (imageUrl)");if(this.xrSession)throw new Error("已经在VR模式中");if(!await this.isVRSupported())throw new Error("设备不支持WebXR VR");if(!this.isInitialized){if(!this._initWebGL())throw new Error("WebGL初始化失败");if(!this._initShaders())throw new Error("着色器初始化失败");this._createSphere(),await this._loadTexture(),this.isInitialized=!0}try{this.xrSession=await navigator.xr.requestSession("immersive-vr",{optionalFeatures:["local-floor","bounded-floor"]})}catch(e){throw new Error("无法创建VR会话: "+e.message)}this.xrSession.addEventListener("end",this._onSessionEnd);const e=new XRWebGLLayer(this.xrSession,this.gl,{antialias:!1,depth:!0,stencil:!1,alpha:!1,framebufferScaleFactor:.8});await this.xrSession.updateRenderState({baseLayer:e,depthNear:.1,depthFar:100});try{this.xrRefSpace=await this.xrSession.requestReferenceSpace("local-floor")}catch(e){this.xrRefSpace=await this.xrSession.requestReferenceSpace("local")}this.xrSession.requestAnimationFrame((e,t)=>this._onXRFrame(e,t)),this.onVRStart()}async exitVR(){this.xrSession&&(this.xrSession.removeEventListener("end",this._onSessionEnd),await this.xrSession.end(),await this._onSessionEnd(),console.log("exitVR 结束"))}async _onSessionEnd(){console.log("XR会话已结束"),await this._cleanup()}async _cleanup(){console.log("清理VR会话和资源"),this.xrSession||this.isInitialized?(this.xrSession=null,this.xrRefSpace=null,this.autoDestroyOnExit&&await this.destroy(),this.onVREnd(),console.log("VR资源已释放，退出回调已触发")):console.log("无需清理，VR会话和资源均已释放")}_onXRFrame(e,t){if(!this.xrSession)return;const r=t.session;r.requestAnimationFrame((e,t)=>this._onXRFrame(e,t));const i=t.getViewerPose(this.xrRefSpace);if(!i)return;const o=this.gl,s=r.renderState.baseLayer;o.bindFramebuffer(o.FRAMEBUFFER,s.framebuffer),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT);for(const e of i.views){const t=s.getViewport(e);o.viewport(t.x,t.y,t.width,t.height),this._renderScene(e.projectionMatrix,e.transform.inverse.matrix)}}_renderScene(e,t){const r=this.gl;this.textureLoaded&&(r.useProgram(this.programInfo.program),r.bindBuffer(r.ARRAY_BUFFER,this.sphereBuffers.position),r.vertexAttribPointer(this.programInfo.attribLocations.position,3,r.FLOAT,!1,0,0),r.enableVertexAttribArray(this.programInfo.attribLocations.position),r.bindBuffer(r.ARRAY_BUFFER,this.sphereBuffers.texCoord),r.vertexAttribPointer(this.programInfo.attribLocations.texCoord,2,r.FLOAT,!1,0,0),r.enableVertexAttribArray(this.programInfo.attribLocations.texCoord),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,this.sphereBuffers.indices),r.uniformMatrix4fv(this.programInfo.uniformLocations.projectionMatrix,!1,e),r.uniformMatrix4fv(this.programInfo.uniformLocations.modelViewMatrix,!1,t),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,this.texture),r.uniform1i(this.programInfo.uniformLocations.texture,0),r.drawElements(r.TRIANGLES,this.sphereBuffers.vertexCount,r.UNSIGNED_SHORT,0))}async destroy(){if(this.isInitialized){if(console.log("销毁VR查看器并释放所有资源"),this.xrSession&&(console.log("销毁时发现会话仍然存在，正在结束会话..."),await this.xrSession.end(),console.log("VR会话已结束")),this.gl){const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.bindTexture(e.TEXTURE_2D,null),e.useProgram(null),this.texture&&(e.deleteTexture(this.texture),this.texture=null),this.sphereBuffers&&(e.deleteBuffer(this.sphereBuffers.position),e.deleteBuffer(this.sphereBuffers.texCoord),e.deleteBuffer(this.sphereBuffers.indices),this.sphereBuffers=null),this.shaderProgram&&(e.deleteProgram(this.shaderProgram),this.shaderProgram=null)}if(this.canvas){const e=this.canvasId,t=this.canvas;await new Promise(r=>{const i=()=>{const t=document.getElementById(e);t&&t.parentNode&&t.parentNode.removeChild(t)},o=e=>{e.preventDefault(),i(),t.removeEventListener("webglcontextlost",o),r()};if(this.gl){const e=this.gl.getExtension("WEBGL_lose_context");e?(this.canvas.addEventListener("webglcontextlost",o),e.loseContext()):(i(),r())}else i(),r()})}this.xrSession&&(console.log("销毁前发现会话仍然存在，销毁后补偿触发onVREnd"),this.onVREnd(),console.log("退出回调已触发")),this.gl=null,this.canvas=null,this.programInfo=null,this.textureLoaded=!1,this.isInitialized=!1,this.xrSession=null,this.xrRefSpace=null,console.log("所有资源已释放")}}}"undefined"!=typeof module&&module.exports&&(module.exports=VREquirectangularViewer),"undefined"!=typeof window&&(window.VREquirectangularViewer=VREquirectangularViewer);